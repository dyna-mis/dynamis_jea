#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Sun Dec  1 12:17:03 2019

@author: guangping
"""
import math
import numpy as np
from enum import Enum
from operator import add
import os
import json
import decimal
D = decimal.Decimal
import collections


def algo_partition(path, mod, model, size, skip,update_flag):
    dic = {
        "line": [],
        "g-line": [],
           "grid":[],
        "g-grid": [],
           "grid-2":[],
        "g-grid-2": [],
           "grid-4":[],
           "g-grid-4": [],
        "MIS-graph": [],
        "MIS-ORS": [],
           }
    for x in path.iterdir():
        if x.is_file():

            if skip in  x.name:
                continue
            if update_flag and "recompute" in x.name:
                continue

            if not update_flag and "recompute" not in x.name:
                continue

            if mod in x.name and model in x.name and size in x.name:
                if "graph" in x.name:
                    dic["MIS-graph"].append(x.name)
                elif "ors" in x.name:
                    dic["MIS-ORS"].append(x.name)
                elif "gridK2" in x.name:
                    if "greedy" in x.name:
                        dic["g-grid-2"].append(x.name)
                    else:
                        dic["grid-2"].append(x.name)
                elif "gridK4" in x.name:
                    if "greedy" in x.name:
                        dic["g-grid-4"].append(x.name)
                    else:
                        dic["grid-4"].append(x.name)
                elif "grid" in x.name:
                    if "greedy" in x.name:
                        dic["g-grid"].append(x.name)
                    else:
                        dic["grid"].append(x.name)
                elif "line" in x.name:
                    if "greedy" in x.name:
                        dic["g-line"].append(x.name)
                    else:
                        dic["line"].append(x.name)
    for key, value in dic.items():
        assert len(dic[key]) == 10, (key, len(dic[key]), dic[key], size, dic)

    return dic





def Average(lst): 
    return sum(lst) / len(lst)
def merge_dols(dol1, dol2):
    for key, value in dol1.items():
        dol1[key] = dol1[key] + dol2[key]
    return dol1

def decimalList(l):
    l_new = []
    for i in l:
        l_new.append(float (D(i)))
    return l_new
def turnDict(data_s):
    for key,value in data_s.items():
        if key == "info":
            continue
        if not isinstance(data_s[key], list):
            data_s[key] = [D(value)]
    return data_s
def decimalDict(d):
    for key,value in d.items():
        if key == "updateType":
            continue
        else: d[key] = decimalList(value)

#/home/guangping/dev/RESULT/add/GAUSSIAN/1000/arrow
class folder:
    files = []
    size = 100000
    file_type = 0
    algo_type = 0
    mod_type = 0
    f_data = {}
    def print_info(self):
       print("path: ",self.files)
       print("size: ",self.size)
       print("generated by: ", self.file_type)
       print("algo: ", self.algo_type)
       print("mod: ", self.mod_type)


    def convert(self, name1, name2):
        self.f_data.update({name2:[x/1000000 for x in self.f_data[name1]]})
    def merge(self,name1,name2, sumName):
        self.data.update({sumName:list(map(add,self.data[name1], self.data[name2]))})
    def get_data(self):
        self.f_data = {"updateTime": []}
        for filename in self.files:
            with open(os.path.join(self.path, filename)) as json_file:
                self.f_data = merge_dols(turnDict(self.f_data),turnDict(json.load(json_file)))
        decimalDict(self.f_data)
        self.convert('updateTime','updateFullTime_milisecond')
    def __init__(self,result_path, files, algo_t, mod):
        self.path = result_path
        self.files = files
        self.algo_type = algo_t
        self.mod_type = mod
    def printDATA(self):
        print("data: ")
        print(self.data)
#/home/guangping/dev/RESULT/add/GAUSSIAN/1000/(all algorithms)
class folderList:
    fL_data = collections.OrderedDict()
    def print_info(self):
     for key,value in self.data.items():
         print (key, value)
         value.print_info()     
    def getMAXVALUE(self,name,finalname):
        l = []
        for key,value in self.data.items():
            if key == 'exact':
                continue
            else:
                if len(l)==0:
                    l = value.data[name]
                else:
                    l = np.maximum(l,value.data[name])
        for key,value in self.data.items():
            if key == 'exact':
                continue
            x = [float(b)/float(q) for b,q in zip(value.data[name],l)]
            value.data.update({finalname:x})

    def getAverage(self,l_size,l_time):
        for key,value in self.data.items():
           if key == 'average update time':
               continue
           if key == 'average update size':
               continue
           if key == 'div update time':
               continue
           if key == 'div update size':
               continue
           l_size.update({key:Average(value.data['updateSize'])})
           l_time.update({key:Average(value.data['updateFullTime_milisecond'])})
    def getDIV(self,l_size,l_time):
        for key,value in self.data.items():
           if key == 'average update time':
               continue
           if key == 'average update size':
               continue
           if key == 'div update time':
               continue
           if key == 'div update size':
               continue
           l_size.update({key:(np.std(value.data['updateSize'])/math.sqrt(len(value.data['updateSize'])))})
           l_time.update({key:(np.std(value.data['updateFullTime_milisecond'])/
                               math.sqrt(len(value.data['updateFullTime_milisecond'])))})
    def order(self,l):
        for key in l:
            self.fL_data[key] = self.fL_data.pop(key)
    def __init__(self, result_path,mod, model, size, skip, update):
        algo_dic = algo_partition(result_path, mod, model, size, skip,update)
        objs = list()
        for key, value in algo_dic.items():
            objs.append(folder(result_path, value, key, mod))
            objs[-1].get_data()
            e = objs[-1].algo_type
            self.fL_data.update({e: objs[-1]})

        self.order(['line','g-line','grid','g-grid','grid-2','g-grid-2','grid-4','g-grid-4','MIS-ORS','MIS-graph'])

        
        